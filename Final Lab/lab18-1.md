# Lab 18.1: Hacking Minesweeper
## Objective 
* Hack minesweeper at binary level
* Learn how to use cheat engine

## Prerequisite
* Ollydbg or x32dbg
* Python
* Procdump
* Cheat Engine
* [minesweeper](https://samsclass.info/126/proj/minesam.exe.zip)

## Lab walkthrough
### Create a cheat script
First, i will run the game and test the game if it's ok

<img width="616" height="677" alt="image" src="https://github.com/user-attachments/assets/268b563f-d056-46ab-ab69-ae090366459f" />

<img width="672" height="639" alt="image" src="https://github.com/user-attachments/assets/632e4f77-164b-4dbd-872b-fcdfb33479a5" />

Look over the result, this game is the normal minesweeper. So i make my assumption:
* First, the game will initialize with a map
* If you choose the bomb, the game will re-initialize the map so your first move should be the one without bomb
* Unlike regular one, the first move you make will be randomize, and they may not give you the first biggest chunk of the game

Continue to the game, i will open it in `x32dbg` 

<img width="2555" height="1519" alt="image" src="https://github.com/user-attachments/assets/22bbb10b-6570-4b06-b7c2-a8ac0ea7f8ac" />

From my assumption, the game should store it map in the memory as it can be change. Let's go to the `memory map`

<img width="2542" height="1502" alt="image" src="https://github.com/user-attachments/assets/331b5ee6-e4ce-4cfa-a533-027967b01a1c" />

At the runtime, data will be stored at:
* `.text` = to store code (RX)
* `.rdata / .idata` = consts, imports (R)
* `.data / .bss` = global & static vars (RW)
* `Heap` = dynamically allocated.
* `Stack` = local variables inside functions.

And base from my previous assumptiom where game should be:
* The map will change overtime by their value (if they want to represent, they have to represent number 1-8, un-opened space, no-value space and bomb)
* It's exists while the game running
* Static size
=> We could guess the map content will be stored at `.data`.

<img width="2554" height="1417" alt="image" src="https://github.com/user-attachments/assets/2039283d-dc8d-4965-8826-82df04c555f6" />

i will try to play at first to see which part is being change during the game run

<img width="2554" height="1435" alt="image" src="https://github.com/user-attachments/assets/da27641c-f8ce-42b2-9786-e4c00843e3e4" />

i found that the map stored at `01005360` which is similar to my game. Also i cam map something like this after seeing the result
* No bomb = `0F`
* has bomb = `8F`
* Bomb reveal = `CC`
* number = `4x`, where x is the number that show on the map, run from 1-8.
* blank = `40`

Also after that, i also find this as right above game's map and it constant even i tried to rerun the game multiple time
```
01005330  0A 00 00 00 09 00 00 00 09 00 00 00 00 00 00 00  ................  
```
if i split it into 4 bytes, and also known when we read it, it should be in `little-endian` then i can craft 4 number `10`, `9`, `9` `0`, somehow it perfectly fit with our game with `10` bombs, `9` rows / cols. To guess my assumption, i will change the game to a bigger size

<img width="1678" height="1093" alt="image" src="https://github.com/user-attachments/assets/a91d0cd9-c0e7-43d7-8772-5a05b085c2d2" />

what can i extract is
```
01005330  28 00 00 00 10 00 00 00 10 00 00 00 00 00 00 00  (...............  
```
which is fit the size of this map

Using `python` and `procdump`, i can craft a script like following to make a map that already show where is the bomb

```
#!/usr/bin/env python3
import sys
import subprocess
import time
from pathlib import Path
from tabulate import tabulate

DUMP_NAME = "mine.dmp"        # legacy expected name (we'll still search for any mine*.dmp)
PROCESS_NAME = "minesam.exe"
DUMP_BASENAME = "mine"        # ProcDump's basename argument (it may create subfolders)
LINE_WIDTH = 32               # number of columns in the board

# Marker used to locate the gameboard in memory (20 bytes)
MARK = (
    b"\x0A\x00\x00\x00"
    b"\x09\x00\x00\x00"
    b"\x09\x00\x00\x00"
    b"\x00\x00\x00\x00"
    b"\x10\x10\x10\x10"
)

PREFIX_LEN = 4
BOARD_DATA_LEN = 500


def find_recent_dump(search_root=".", pattern="**/mine*.dmp", timeout_s=5.0):
    """
    Search recursively for files matching pattern and return the newest one.
    Waits up to timeout_s seconds for a file to appear (polling).
    """
    deadline = time.time() + timeout_s
    while time.time() < deadline:
        matches = list(Path(search_root).glob(pattern))
        if matches:
            best = max(matches, key=lambda p: p.stat().st_mtime)
            return str(best)
        time.sleep(0.2)
    return None


def make_dump():
    # Remove any old mine*.dmp files in CWD tree
    for p in Path(".").glob("**/mine*.dmp"):
        try:
            p.unlink()
        except Exception:
            pass

    cmd = ["procdump", "-ma", PROCESS_NAME, DUMP_BASENAME]
    print("[*] Running:", " ".join(cmd))
    proc = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

    if proc.stdout.strip():
        print(proc.stdout.strip())
    if proc.stderr.strip():
        print(proc.stderr.strip())

    if proc.returncode != 0:
        print("[!] procdump exited with return code", proc.returncode,
              "- continuing to check for dumps...")

    dump_path = find_recent_dump(search_root=".", pattern="**/mine*.dmp", timeout_s=3.0)
    if not dump_path:
        print("[-] No mine*.dmp found after running procdump.")
        sys.exit(1)

    print("[+] Found dump file:", dump_path)
    return dump_path


def find_and_extract_board(dump_path: str):
    gameboard = bytearray()

    with open(dump_path, "rb") as f:
        window = f.read(len(MARK))
        if len(window) < len(MARK):
            print("[-] Dump too small, marker not found.")
            sys.exit(1)

        nread = len(window)

        while True:
            c = f.read(1)
            if not c:
                print("[-] File ended, but gameboard not found!")
                sys.exit(1)

            window = window[1:] + c
            nread += 1

            if nread % 0x100000 == 0:
                print("[*] Looking at byte", hex(nread))

            if window == MARK:
                print("[+] Gameboard marker found ending at byte", hex(nread))
                break

        # Match original behavior: prefix 0x10s, then read board bytes
        gameboard.extend(b"\x10" * PREFIX_LEN)
        data = f.read(BOARD_DATA_LEN)
        if len(data) < BOARD_DATA_LEN:
            print(f"[-] Not enough data after marker for gameboard (read {len(data)}).")
        gameboard.extend(data)

    return bytes(gameboard)


def _byte_to_cell(g: int) -> str:
    """
    Map raw byte to a display symbol (Minesweeper-like).
    Adjust symbols to taste.
    """
    if g == 0x10:
        return "■"      # covered / unknown
    elif g == 0x0F:
        return " "      # revealed empty
    elif g == 0x8F:
        return "*"      # mine
    elif g == 0x00:
        return " "      # blank / padding
    else:
        val = g - 16
        # printable ASCII → treat as number/char, else placeholder
        return chr(val) if 32 <= val <= 126 else "?"


def decode_board(gameboard: bytes, width: int = LINE_WIDTH):
    """
    Convert linear gameboard bytes into a 2D list of cell strings.
    Only keeps full rows of 'width' cells.
    """
    if width <= 0:
        raise ValueError("width must be positive")

    full_len = (len(gameboard) // width) * width
    rows = []
    for i in range(0, full_len, width):
        row_bytes = gameboard[i:i + width]
        row = [_byte_to_cell(b) for b in row_bytes]
        rows.append(row)
    return rows


def print_minesweeper_window(gameboard: bytes):
    """
    Pretty-print the board as a fake Minesweeper window in the terminal.
    """
    rows = decode_board(gameboard, LINE_WIDTH)
    if not rows:
        print("[-] Gameboard smaller than expected.")
        return

    # Build grid with borders (tabulate handles box drawing)
    grid = tabulate(
        rows,
        tablefmt="fancy_grid",
        stralign="center",
        disable_numparse=True,
    )

    grid_lines = grid.splitlines()
    width = len(grid_lines[0]) if grid_lines else 0

    # Fake counters / header bar for visuals
    # (You can wire these up to real values later if you want.)
    left_counter = "[000]"
    right_counter = "[000]"
    smiley = "[ : ) ]"

    header = f"{left_counter}   {smiley}   {right_counter}"
    title_bar = " MINESWEEPER ".center(width, "═")

    # Print the "window"
    print(title_bar)
    print(header.center(width))
    print("".center(width, "─"))
    print(grid)


def main():
    dump_path = make_dump()
    gameboard = find_and_extract_board(dump_path)
    print_minesweeper_window(gameboard)


if __name__ == "__main__":
    main()

```

<img width="2326" height="1249" alt="image" src="https://github.com/user-attachments/assets/d55fa87c-d6f1-49ae-a733-1951c48e8de6" />

### Modified with Cheat Engine 
Open `Cheat Engine` and the game

<img width="1350" height="1105" alt="image" src="https://github.com/user-attachments/assets/4fe8f2e9-3799-4873-a17b-93aed25bdc40" />

in `Cheat Engine` open the choose the target process

<img width="686" height="821" alt="image" src="https://github.com/user-attachments/assets/8965c977-5c50-44e3-be1a-c2face69c9dc" />

At the first time, we will choose our current bomb number, which is `10`, then scan it

<img width="1322" height="1108" alt="image" src="https://github.com/user-attachments/assets/30490cce-1869-4e5f-8a59-9363ec521a65" />

After that, change the game difficulty to `Expert`

<img width="1020" height="735" alt="image" src="https://github.com/user-attachments/assets/7fd2c1fe-1053-4597-bd08-a62f1e31874e" />

In `Cheat Engine` search for number `99`

<img width="1188" height="1029" alt="image" src="https://github.com/user-attachments/assets/32287f2b-1ce1-4378-a738-86b77c43a274" />

Add them to address list and change their value to `1`

<img width="959" height="708" alt="image" src="https://github.com/user-attachments/assets/0a7bb59c-8617-4449-857e-8460ea7694ac" />

locking them, then restart the game

<img width="2367" height="1389" alt="image" src="https://github.com/user-attachments/assets/ed2353bc-a8ff-4e50-8d1a-4a2ded7aa7b5" />
